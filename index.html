<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
  fill: steelblue;
  stroke: steelblue;
}

</style>
<body>
<script src="d3/d3.min.js"></script>
<script>

var width = 960,
    height = 600;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var geojson_arr = [];

//
var generatedPath;
var completed = 0;
var nbSteps = 4;

// Surprisingly difficult to wait for ALL JSON files to have arrived (inside a loop)

d3.json("data/0.json", function(error,json) {
  geojson_arr[0] = json.features[0].geometry;
  if (++completed==nbSteps) {initTransition();}
});

d3.json("data/1.json", function(error,json) {
  geojson_arr[1] = json.features[0].geometry;
  if (++completed==nbSteps) {initTransition();}
});

d3.json("data/2.json", function(error,json) {
  geojson_arr[2] = json.features[0].geometry;
  if (++completed==nbSteps) {initTransition();}
});

d3.xml("data/3.svg", "image/svg+xml", function(xml) {
  geojson_arr[3] = {"path":xml.documentElement.childNodes[3].childNodes[1].attributes[0].nodeValue};
  if (++completed==nbSteps) {initTransition();}
});

var initTransition = function(){
  var projection = d3.geo.albers()
      .rotate([120, 0])
      .center([0, 37.7])
      .scale(1000);

  // Transforming the coordinates into an SVG path (linear)
  var darr = [];
  for(var k=0; k<geojson_arr.length;k++)
  {
    if (geojson_arr[k].coordinates)
    {
      darr[k] = "M" + geojson_arr[k].coordinates[0].map(projection).join("L") + "Z";
    }
    else
    {
      var svg2 = d3.select("body").append("svg")
        .attr("width", 0)
        .attr("height", 0);

      var seg = svg2.append('path')
        .attr('d', geojson_arr[k].path).node().pathSegList;
      var segPathData = d3.range(seg.numberOfItems).map(function(d, i){
        var item = seg.getItem(i); 
        return {type: item.pathSegTypeAsLetter, x: item.x, y: item.y};
      });

      // Rewriting the SVG coordinates
      segPathData[0].x = 960/2; // center of the SVG element
      segPathData[0].y = 20;

      // Transforming to absolute coordinates
      for (var m=1;m<seg.numberOfItems-1;m++)
      {
        // Getting to a 1/10th scale
        segPathData[m].x = segPathData[m-1].x+segPathData[m].x/10;
        // Minus sign here to mirror the image (used to be done by negative Y-scaling)
        segPathData[m].y = segPathData[m-1].y-segPathData[m].y/10;
      }

      // Ending the path correctly: removing the Z element
      segPathData.pop();

      // Using interpolation function
      var lineFunction = d3.svg.line()
                             .x(function(d) { return d.x; })
                             .y(function(d) { return d.y; })
                             .interpolate("linear");

      // Using a path
      var lineGraph = svg2.append("path")
                        .attr("d", lineFunction(segPathData));

      // The path string can be accessed using this cryptic object access path
      darr[k] = d3.select(lineGraph[0][0]).attr('d');
    }
  }

/*
  generatedPath = "M1960 4969 c-33 -20 -80 -67 -80 -79 0 -3 -22 -23 -50 -44 -27 -21 -50 -43 -50 -49 0 -6 -11 -20 -24 -32 -18 -14 -26 -34 -31 -70 -12 -99 -57 -254 -91 -314 -30 -53 -35 -82 -38 -211 -3 -97 -21 -155 -51 -166 -8 -3 -28 -28 -45 -55 -33 -54 -40 -105 -21 -153 12 -30 7 -66 -10 -66 -9 0 -95 -177 -105 -217 -6 -23 -69 -49 -107 -44 -10 1 -30 -6 -45 -16 -15 -9 -40 -25 -57 -34 -24 -13 -30 -23 -31 -50 0 -19 -11 -66 -22 -105 -26 -84 -27 -94 -7 -94 10 0 15 -11 16 -32 0 -18 2 -42 4 -53 2 -11 -7 -34 -20 -51 -24 -31 -24 -33 -10 -87 8 -30 24 -73 36 -96 31 -60 37 -183 10 -217 -21 -26 -21 -65 -3 -154 5 -25 8 -65 7 -90 -2 -25 -4 -55 -4 -68 -1 -13 -14 -35 -31 -51 -28 -25 -30 -32 -31 -101 -1 -76 0 -90 22 -212 10 -55 18 -73 44 -97 18 -16 47 -59 64 -95 30 -63 30 -66 14 -94 -15 -26 -15 -36 -5 -84 7 -30 21 -64 30 -74 57 -62 70 -88 67 -141 -2 -29 0 -53 4 -54 3 0 15 -2 26 -5 19 -3 34 -6 120 -19 22 -4 51 -14 65 -22 27 -18 65 -24 155 -25 45 -1 74 -8 118 -30 47 -23 62 -27 73 -17 11 9 26 8 67 -4 73 -23 77 -23 129 2 26 12 63 22 84 24 35 2 37 0 48 -38 7 -22 11 -67 9 -100 -3 -48 -8 -63 -26 -77 -26 -20 -25 -60 4 -96 28 -36 18 -43 -75 -56 -54 -8 -9 -39 75 -52 69 -10 243 -13 255 -3 6 5 9 20 7 32 -4 19 -11 23 -34 22 -21 -1 -30 4 -35 19 -10 31 -12 247 -3 280 12 41 52 97 60 84 5 -7 60 -11 156 -12 157 -1 183 -8 223 -58 14 -17 21 -18 65 -8 28 7 65 12 83 12 34 0 62 20 62 43 0 7 13 18 28 23 27 9 30 16 41 84 7 41 19 85 27 97 14 20 14 24 0 46 -21 32 -46 105 -35 105 4 0 19 -4 33 -10 25 -9 38 -2 42 25 2 15 76 137 96 159 20 22 19 16 20 113 l0 73 47 0 c47 0 52 3 87 65 6 11 34 58 63 104 36 57 50 90 45 103 -3 11 -7 37 -8 59 -2 25 -11 48 -26 64 -23 25 -28 25 -80 7 -10 -3 -8 3 6 19 34 38 52 81 59 139 3 30 8 56 10 59 2 2 -2 13 -10 25 -8 11 -15 42 -15 68 0 63 -39 159 -85 210 -33 36 -36 44 -31 80 3 22 17 60 30 84 l24 44 -37 29 c-21 17 -52 57 -69 90 -23 42 -41 62 -61 69 -22 8 -34 24 -55 76 -14 36 -26 73 -26 82 0 8 -11 35 -25 59 -13 25 -26 62 -28 82 -4 33 -8 39 -32 43 -25 4 -31 13 -46 64 -10 33 -19 71 -21 85 -1 14 -9 34 -16 43 -10 12 -12 22 -5 30 26 32 23 65 -7 103 -17 21 -33 50 -35 64 -3 14 -15 53 -27 86 -11 33 -23 89 -24 125 -5 83 -6 86 -30 140 -27 58 -64 180 -64 209 0 15 -7 25 -22 29 -34 9 -130 61 -155 84 -20 18 -20 22 -7 53 13 32 13 35 -13 55 -19 15 -29 17 -34 9 -8 -14 -74 -6 -135 17 -36 14 -42 21 -58 69 -17 47 -23 54 -55 63 -20 6 -67 23 -106 38 -97 37 -188 42 -235 13z";

*/
  // Cloning the original array and initialising the 1st transition
  var darr2 = darr.slice(0);
  var d0 = darr2.shift();
  var d1 = darr2.shift();

  svg.append("path")
      .attr("d", d0)
      .call(transition, d0, d1);

  function transition(path, d0, d1) {
    path.transition()
        // 3 seconds for the animation to play out
        .duration(3000)
        // Precision of 1 is required to avoid a flash of corrected coordinates on loop end
        .attrTween("d", pathTween(d1, 1))
        // On transition end, proceed to the next transition
        .each("end", function() {
          d0 = d1;
          if (!darr2.length)
          {
            darr2 = darr.slice(0);
          }
          d1 = darr2.shift();
          d3.select(this).call(transition, d0, d1);
        });
  }

  function pathTween(d1, precision) {
    return function() {
      var path0 = this;
      var path1 = path0.cloneNode();
      var n0 = path0.getTotalLength();
      var n1 = (path1.setAttribute("d", d1), path1).getTotalLength();

      // Uniform sampling of distance based on specified precision.
      var distances = [0], i = 0, dt = precision / Math.max(n0, n1);
      while ((i += dt) < 1) distances.push(i);
      distances.push(1);

      // Compute point-interpolators at each distance.
      var points = distances.map(function(t) {
        var p0 = path0.getPointAtLength(t * n0),
            p1 = path1.getPointAtLength(t * n1);
        return d3.interpolate([p0.x, p0.y], [p1.x, p1.y]);
      });

      return function(t) {
        return t < 1 ? "M" + points.map(function(p) { return p(t); }).join("L") : d1;
      };
    };
  }

} 

</script>